# :octocat: Robot Controller

**Robot Controller** is a Python script designed to manage an iRobot Create2 (Roomba) through manual and automatic modes. The script leverages the `pycreate2` library for direct communication with the robot, with real-time data visualization using `matplotlib` and `tkinter` for a GUI.

## Functionality

### 1. **Modes of Operation**:
   - **Manual Mode**: Enables direct control of the robot using keyboard arrows, providing instant movement adjustments and testing flexibility.
   - **Automatic Mode**: Runs the robot on a pre-defined path generated by the A* algorithm with both Euclidean and Manhattan heuristics, ideal for testing route-following capabilities and movement precision.

### 2. **Pathfinding with A\* Algorithm**:
   - **A\* Pathfinding**: The script uses an A* algorithm to determine the optimal path from a starting position to a defined goal. A* is known for its efficiency in pathfinding by combining a priority queue with cost-tracking to find the shortest path.
   - **Heuristics**:
     - **Manhattan Heuristic**: Used for cardinal (straight) movements, this heuristic calculates the distance in a grid-based environment as the sum of absolute differences in the x and y coordinates.
     - **Euclidean Heuristic**: Used for diagonal movements, this heuristic calculates the straight-line distance to the target, providing more accurate distance estimation for diagonal paths.
   - **Priority Queue Management**: The `a_star()` function initiates a priority queue and tracks node costs, continually updating and comparing neighbors to find the most efficient route.

### 3. **Odometry and Speed Control**:
   - **Position Calculation**: The script continuously updates the robot's position `(x, y)` and orientation using encoder data, calculated through `Odometer`.
   - **Straight Movements**: The robot moves at a speed of 100 or -100 for forward and backward movements.
   - **Rotational Movements**: For rotation, the robot alternates between speeds of 60 and -60, allowing it to turn smoothly both left and right.

### 4. **Graphical Visualization (GUI)**:
   - **Interactive Plotting**: The GUI provides an interactive `matplotlib` plot to visualize the robot's real-time path, positions, and rotations, facilitated by a `tkinter`-based control interface.
   - **Configuration and Layout**:
     - A queue (`self.queue`) manages update requests, making real-time plotting smooth and non-blocking.
     - The interactive mode in `matplotlib` (`plt.ion()`) allows for continuous updates without freezing the display.
     - A single subplot (`self.fig, self.ax`) is configured with labels, a title ("iRobot Roomba 650 Pathing"), and grid lines, with x and y limits set to (-2, 2) meters for clarity.

   - **Robot Representation**:
     - An image of the iRobot is loaded and adjusted to scale using `self.irobot_png` with a defined size of `0.1` (10% of the plot scale). The robot's current position updates on each movement using `update_plot()`.
     - The robot’s image position on the plot is dynamically adjusted based on its updated `(x, y)` coordinates, allowing smooth visual tracking of rotations and translations.

   - **Trajectory Tracking**:
     - **Path Recording**: The robot's position is appended to `self.trajectory`, and each segment is drawn on the plot with a red line.
     - **Plot Updates**: `update_plot()` refreshes the robot's position and trajectory, calling `plt.pause(0.01)` for smooth animations.
     - **Queue-Based Updates**: `process_queue()` manages and processes plot updates asynchronously, checking for "update" messages in the queue to trigger `update_plot()` without delay.
       
## Main Classes

### `RobotController`

This class handles the connection and communication with the robot, managing both manual and automatic movement. It is also responsible for odometry updates, calculating and visualizing the robot's real-time position.

   - **Attributes**:
     - `self.port`, `self.baud`: Communication port and baud rate for robot connection.
     - `self.bot`: Instance of `Create2` from `pycreate2`, enabling robot interaction.
     - `self.odometer`: An instance of `Odometer` to calculate position based on encoder data.
     - `self.queue`: Queue structure to manage movement commands and data.
     - `self.fig`, `self.ax`: Elements from `matplotlib` for GUI plotting.

   - **Primary Methods**:
     - `initialize_robot()`: Establishes the connection with the robot and sets up the initial GUI configurations, loading the iRobot image and creating the coordinate grid.
     - `manual_control()`: Allows direct movement commands through keyboard inputs.
     - `automatic_control()`: Runs a pre-set series of movements autonomously.
     - `draw_robot()`: Updates the robot's position in the GUI, showing real-time trajectory and orientation.

### `Odometer`

The `Odometer` class handles odometry calculations, enabling precise tracking of position and orientation based on encoder readings.

   - **Attributes**:
     - `self.bot`: Reference to the `Create2` instance.
     - `self.x`, `self.y`: Current coordinates of the robot.
     - `self.angle`: Orientation in radians.

   - **Primary Methods**:
     - `initialize_odometry()`: Sets initial values for position and orientation.
     - `update_odometry()`: Updates `(x, y)` position and `angle` based on encoder readings, calculating distance and rotation traveled.

### Command Interface

The `CommandInterface` class provides an interface for user commands to control a robot. It utilizes ANSI color codes for improved readability in the command line.

#### Methods

#### `read_command(mode='manual')`

Prompts the user for commands based on the specified mode.

- **Parameters**:
  - `mode` (str): Can be either `'manual'` or `'auto'`.
  
- **Returns**: User input as a string.

- **Modes**:
  - **manual**: Prompts for commands such as moving, turning, quitting, singing, or help.
  - **auto**: Prompts for target coordinates in the form `[X, Y]` along with options to quit or seek help.

#### `print_command_help()`

Displays a list of available manual commands:

- `m <distance_cm>`: Move the robot forward (positive) or backward (negative) by a distance in cm.
- `g <angle_degrees>`: Turn the robot left (positive) or right (negative) by a specified angle in degrees.
- `q`: Quit the program.

**Examples**:
- `m 50` → Moves the robot 50 cm forward.
- `m -30` → Moves the robot 30 cm backward.
- `g 90` → Turns the robot 90 degrees to the left.
- `g -45` → Turns the robot 45 degrees to the right.
- `q` → Exits the program.

#### `print_auto_command_help()`

Displays a list of available automatic commands:

- `<x> <y>`: Sets the target coordinates (X, Y) for the robot to move to.
- `q`: Quit the program.

**Examples**:
- `4 -1` → Moves the robot to the coordinate (4, -1).
- `0 0` → Moves the robot back to the origin (0, 0).
- `q` → Exits the program.

## Running the Script

1. **Initial Configuration**: Connect the iRobot to the computer’s serial port (default: `COM3`). Modify the port if needed.

2. **Run the Script**: Open a terminal and execute:
   ```bash
   python go.py
   ```
3. **Command-Line Arguments**: The robot can be controlled via command-line arguments using the `argparse` module. The following parameters can be specified:

```python
parser = argparse.ArgumentParser(description="Control de robot con parámetros.")
parser.add_argument('--port', type=str, default=DEFAULT_PORT, help='Ruta del puerto del robot.')
parser.add_argument('--baud', type=int, default=DEFAULT_BAUD['default'], help='Velocidad de baudios para la comunicación con el robot.')
parser.add_argument('--mode', type=str, default='manual', choices=['manual', 'auto'], help='Modo de ejecución (manual o automático).')
```
