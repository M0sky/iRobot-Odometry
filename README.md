# :octocat: iRobot Roomba 650

**Go.py** is a Python script designed to manage an iRobot Create2 (Roomba) through manual and automatic modes. The script leverages the `pycreate2` library for direct communication with the robot, with real-time data visualization using `matplotlib` and `tkinter` for a GUI.

## Functionality

### 1. **Modes of Operation**:
   - **Manual Mode**: Enables direct control of the robot using keyboard arrows, providing instant movement adjustments and testing flexibility.
   - **Automatic Mode**: Runs the robot on a pre-defined path generated by the A* algorithm with both Euclidean and Manhattan heuristics, ideal for testing route-following capabilities and movement precision.

### 2. **Pathfinding with A\* Algorithm**:
   - **A\* Pathfinding**: The script uses an A* algorithm to determine the optimal path from a starting position to a defined goal. A* is known for its efficiency in pathfinding by combining a priority queue with cost-tracking to find the shortest path.
   - **Heuristics**:
     - **Manhattan Heuristic**: Used for cardinal (straight) movements, this heuristic calculates the distance in a grid-based environment as the sum of absolute differences in the x and y coordinates.
     - **Euclidean Heuristic**: Used for diagonal movements, this heuristic calculates the straight-line distance to the target, providing more accurate distance estimation for diagonal paths.
   - **Priority Queue Management**: The `a_star()` function initiates a priority queue and tracks node costs, continually updating and comparing neighbors to find the most efficient route.

### 3. **Odometry and Speed Control**:
   - **Position Calculation**: The script continuously updates the robot's position `(x, y)` and orientation using encoder data, calculated through `Odometer`.
   - **Straight Movements**: The robot moves at a speed of 100 or -100 for forward and backward movements.
   - **Rotational Movements**: For rotation, the robot alternates between speeds of 60 and -60, allowing it to turn smoothly both left and right.

### 4. **Graphical Visualization (GUI)**:
   - **Interactive Plotting**: The GUI provides an interactive `matplotlib` plot to visualize the robot's real-time path, positions, and rotations, facilitated by a `tkinter`-based control interface.
   - **Configuration and Layout**:
     - A queue (`self.queue`) manages update requests, making real-time plotting smooth and non-blocking.
     - The interactive mode in `matplotlib` (`plt.ion()`) allows for continuous updates without freezing the display.
     - A single subplot (`self.fig, self.ax`) is configured with labels, a title ("iRobot Roomba 650 Pathing"), and grid lines, with x and y limits set to (-2, 2) meters for clarity.

   - **Robot Representation**:
     - An image of the iRobot is loaded and adjusted to scale using `self.irobot_png` with a defined size of `0.1` (10% of the plot scale). The robot's current position updates on each movement using `update_plot()`.
     - The robot’s image position on the plot is dynamically adjusted based on its updated `(x, y)` coordinates, allowing smooth visual tracking of rotations and translations.

   - **Trajectory Tracking**:
     - **Path Recording**: The robot's position is appended to `self.trajectory`, and each segment is drawn on the plot with a red line.
     - **Plot Updates**: `update_plot()` refreshes the robot's position and trajectory, calling `plt.pause(0.01)` for smooth animations.
     - **Queue-Based Updates**: `process_queue()` manages and processes plot updates asynchronously, checking for "update" messages in the queue to trigger `update_plot()` without delay.
       
## Main Classes

### `RobotController`

This class handles the connection and communication with the robot, managing both manual and automatic movement. It is also responsible for odometry updates, calculating and visualizing the robot's real-time position.

- **Attributes**:
  - `self.port`, `self.baud`: Communication port and baud rate for robot connection.
  - `self.bot`: Instance of `Create2` from `pycreate2`, enabling robot interaction.
  - `self.odometer`: An instance of `Odometer` to calculate position based on encoder data.
  - `self.plotter`: For plotting the robot's trajectory.
  - `self.queue`: Queue structure to manage movement commands and data.
  - `self.running`: Boolean to check if the robot is currently running.
  - `self.mode`: Current operation mode (manual or automatic).
  - `self.back`: Boolean flag indicating whether to move backward.
  - `self.trajectory`: List to store the robot's trajectory.
  - `self.current_path`: List to keep track of the current path for returning.

- **Primary Methods**:
  - `__init__(self, port=DEFAULT_PORT, baud=DEFAULT_BAUD['default'])`: Initializes the robot controller with default communication settings.
  - `initialize_robot()`: Establishes the connection with the robot, initializes odometry, sets up the GUI, and prepares for movement.
  - `close_robot()`: Safely closes the connection with the robot, stopping its movement and freeing resources.
  - `run(self)`: Parses command-line arguments, initializes the robot, and starts either manual or automatic control based on the provided mode.
  - `return_orientation(self)`: Adjusts the robot's orientation to the initial angle based on its current angle.
  - `follow_path(self, path)`: Moves the robot through the specified path, navigating from node to node while updating odometry and trajectory.
  - `update_plot(self)`: Updates the graphical representation of the robot's position and trajectory in real-time.
  - `close(self)`: Closes the plot figure.
  - `process_queue(self)`: Processes queued commands to update the robot's state and visuals without blocking.
  - `move(self, distance_cm)`: Moves the robot forward or backward by a specified distance, controlling movement with odometry and handling encoder readings, including obstacle detection and response.
  - `turn(self, angle_deg)`: Rotates the robot to a specified angle using odometry, managing encoder readings and handling potential errors such as encoder overflow.
  - `canta(self, seleccion)`: Plays a selected song from a predefined set. The method validates the selection, creates the song in the robot, and plays it, waiting for the duration of the song to finish before continuing.
  - `handle_encoder_overflow(self, previous_value, current_value, max_value)`: Manages encoder overflow by calculating the difference between previous and current encoder values. It adjusts the difference to account for overflow in both positive and negative directions.
  - `set_goal(self, goal_x, goal_y)`: Defines the target position on the grid for the robot to navigate towards.
  - `a_star(self)`: Executes the A* algorithm to find the shortest path from the robot's starting position to the defined goal. It uses a priority queue to explore nodes and applies heuristics for efficient pathfinding.
  - `manhattan_heuristic(self, current)`: Calculates the Manhattan heuristic to the goal. It computes the sum of the absolute differences in the x and y coordinates, scaled by the step distance.
  - `euclidean_heuristic(self, current)`: Calculates the Euclidean heuristic to the goal. It computes the straight-line distance to the goal using the Pythagorean theorem, scaled by the step distance.
  - `reconstruct_path(self, current)`: Reconstructs the path from the goal back to the start. It traces back the path using the `came_from` dictionary and returns it in the correct order from start to finish.
  - `grid_to_physical_position(self, x, y)`: Converts grid coordinates (x, y) to physical position in centimeters by multiplying the grid coordinates by the step distance.

### `Odometer`

The `Odometer` class enables precise tracking of the robot's position and orientation using encoder readings.

#### Attributes

- **`self.bot`**: Reference to the `Create2` object.
- **`self.current_position`**: Current position as `[x, y]` in mm.
- **`self.current_angle`**: Current orientation in degrees.
- **`self.wheel_diameter`**: Wheel diameter (72.0 mm).
- **`self.wheel_base`**: Distance between wheels (235.0 mm).
- **`self.ticks_per_revolution`**: Encoder ticks per wheel revolution (508.8).
- **`self.mm_per_tick`**: Millimeters traveled per encoder tick.
- **`self.last_left_encoder`** / **`self.last_right_encoder`**: Previous encoder readings for calculations.
- **`Bumper Attributes`**: For detecting bumps and drops.
- **`Light Bumper Attributes`**: Six sensors for detecting nearby obstacles.
- **`self.starting_position`**: Initial position for the coordinate system.
- **`self.grid_coordinates`**: Stores current grid cell coordinates.

#### Methods

- **`__init__(self, bot)`**: Initializes the odometer attributes.  
- **`initialize_odometry(self)`**: Sets the initial position to `(0, 0)` and updates the grid coordinates.
- **`read_position_sensors(self)`**: Returns the initial position based on encoder readings.
- **`read_angle_sensor(self)`**: Calculates the initial angle based on encoder differences.
- **`update_grid_coordinates(self)`**: Updates grid coordinates based on current position.
- **`get_sensor_data(self)`**: Retrieves sensor data from the `Create2` object.
- **`update_odometry(self)`**: Updates position and angle based on current encoder readings.
- **`print_odometry(self)`**: Displays current odometry to the console.

### `CommandInterface`

The `CommandInterface` class provides an interface for user commands to control a robot. It utilizes ANSI color codes for improved readability in the command line.

#### Methods

- **`read_command(mode='manual')`**: Prompts the user for commands based on the specified mode.
- **`print_command_help()`**: Displays a list of available manual commands:
- **`print_auto_command_help()`**: Displays a list of available automatic commands:

## Running the Script

1. **Initial Configuration**: Connect the iRobot to the computer’s serial port (default: `COM3`). Modify the port if needed.

2. **Run the Script**: Open a terminal and execute:
   ```bash
   python go.py
   ```
3. **Command-Line Arguments**: The robot can be controlled via command-line arguments using the `argparse` module. The following parameters can be specified:

```python
parser = argparse.ArgumentParser(description="Control de robot con parámetros.")
parser.add_argument('--port', type=str, default=DEFAULT_PORT, help='Ruta del puerto del robot.')
parser.add_argument('--baud', type=int, default=DEFAULT_BAUD['default'], help='Velocidad de baudios en comunicación.')
parser.add_argument('--mode', type=str, default='manual', choices=['manual', 'auto'], help='Modo de ejecución.')
```
## 📹 Video

You can download or view the proof of concept videos here:

- **[Desktop View](https://drive.google.com/file/d/1yMsb9Z0hmi3U5p4agsuoydLuL4zZW2Ba/preview)** 💻
- **[iRobot Demo](https://drive.google.com/file/d/18DJL_V73mZezgqLEl0DS7_B8TRwXr70_/preview)** 🤖
